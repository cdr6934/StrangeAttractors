[
["index.html", "Strange Attractors 1 Why This Book Is For You", " Strange Attractors Julien C. Sprott 2019-10-29 1 Why This Book Is For You Art and science sometimes appear in juxtaposition, one aesthetic, the other analytical. This book bridges the two cultures. I have written it for the artist who is willing to devote a modicum of effort to understanding the mathematical world of the scientist and for the scientist who often overlooks the beauty that lurks just beneath even the simplest equations. If you are neither artist nor scientist, but own a personal computer for which you would like to find an exciting new use, this book is also for you. Fractals generated by computer represent a new art form that anyone can appreciate and appropriate. You don’t have to know mathematics beyond elementary algebra, and you don’t have to be an expert programmer. This book explains a simple, new technique for generating a class of fractals called strange attractors. Unlike other books about fractals that teach you to reproduce well-known patterns, this one will let you produce your own unlimited variety of displays and musical sounds with a single program. Almost none of the patterns you produce will ever have been seen before. To get the most out of this book, you will need a personal computer, though it need not be a fancy one. It should have a monitor capable of displaying graphics, preferably in color. Some knowledge of BASIC is useful, although you can just type in the listings even if you don’t understand them completely. For those of you who are C programmers, I have provided an appendix with an equivalent version in C. You may find the exercises in this book an enjoyable way to hone your programming skills. As you progress through the book, you will gradually develop a very sophisticated computer program. Each step is relatively simple and brings exciting new things to see and explore. Alternately, you can use the accompanying disk immediately to begin making your own collection of strange attractors. "],
["intro.html", "2 Order and Chaos 2.1 Predictability and Uncertainty 2.2 Bucks and Bugs 2.3 The Butterfly Effect 2.4 The Computer Artist", " 2 Order and Chaos library(tidyverse) library(numDeriv) This chapter lays the groundwork for everything that follows in the book. Nearly all the essential ideas, mathematical techniques, and programming tools you need are developed here. Once you’ve mastered the material in this chapter, the rest of the book is smooth sailing. 2.1 Predictability and Uncertainty The essence of science is predictability. Halley’s comet will return to the vicinity of Earth in the year 2061. Not only can astronomers predict the very minute when the next solar eclipse will occur but also the best vantage point on Earth from which to view it. Scientific theories stand or fall according to whether their predictions agree with detailed, quantitative observation. Such successes are possible because most of the basic laws of nature are deterministic, which means they allow us to determine exactly what will happen next from a knowledge of present conditions. However, if nature is deterministic, there is no room for free will. Human behavior would be predetermined by the arrangements of the molecules that make up our brains. Every cloud that forms or flower that grows would be a direct and inevitable result of processes set into motion eons ago and over which there is no possibility for exercising control. Perfect predictability is dull and uninteresting. Such is the philosophical dilemma that often separates the arts from the sciences. One possible resolution was advanced in the early decades of the 20th century when it was discovered that the quantum mechanical laws that govern the behavior of atoms and their constituents are apparently probabilistic, which means they allow us to predict only the probability that something will happen. Quantum mechanics has been extremely successful in explaining the submicroscopic world, but it was never fully embraced by some scientists, including Albert Einstein, who until his dying day insisted that he did not believe that God plays dice with the Universe Since the 1970s science has been undergoing an intellectual revolution that may be as significant as the development of quantum mechanics. It is now widely understood that deterministic is not the same as predictable. An example is the weather. The weather is governed by the atmosphere, and the atmosphere obeys deterministic physical laws. However, long-term weather predictions have improved very little as a result of careful, detailed observations and the unleashing of vast computer resources. The reason for this unpredictability is that the weather exhibits extreme sensitivity to initial conditions. A tiny change in today’s weather (the initial conditions) causes a larger change in tomorrow’s weather and an even larger change in the next day’s weather. This sensitivity to initial conditions has been dubbed the butterfly effect, because it is hypothetically possible for a butterfly flapping its wings in Brazil to set off tornadoes in Texas. Since we can never know the initial conditions with perfect precision, long-term prediction is impossible, even when the physical laws are deterministic and exactly known. It has been shown that the predictability horizon in weather forecasting cannot be more than two or three weeks. Unpredictable behavior of deterministic systems has been called chaos, and it has captured the imagination of the scientist and nonscientist alike. The word “chaos” was introduced by Tien-Yien Li and James A. Yorke in a 1975 paper entitled “Period Three Implies Chaos.” The term “strange attractors,” from which this book takes its title, first appeared in print in a 1971 paper entitled “On the Nature of Turbulence,” by David Ruelle and Floris Takens. Some people prefer the term “chaotic attractor,” because what seemed strange when first discovered in 1963 is now largely understood. It’s not hard to imagine that if a system is complicated (with many springs and wheels and so forth) and hence governed by complicated mathematical equations, then its behavior might be complicated and unpredictable. What has come as a surprise to most scientists is that even very simple systems, described by simple equations, can have chaotic solutions. However, everything is not chaotic. After all, we can make accurate predictions of eclipses and many other things. An even more curious fact is that the same system can behave either predictably or chaotically, depending on small changes in a single term of the equations that describe the system. For this reason, chaos theory holds promise for explaining many natural processes. A stream of water, for example, exhibits smooth (laminar) flow when moving slowly and irregular (turbulent) flow when moving more rapidly. The transition between the two can be very abrupt. If two sticks are dropped side-byside into a stream with laminar flow, they stay close together, but if they are dropped into a turbulent stream, they quickly separate. Chaotic processes are not random; they follow rules, but even simple rules can produce extreme complexity. This blend of simplicity and unpredictability also occurs in music and art. A piece of music that consists of random notes or of an endless repetition of the same sequence of notes would be either disastrously discordant or unbearably boring. Likewise, a work of art produced by throwing paint at a canvas from a distance or by endlessly replicating a pattern, as in wallpaper, is unlikely to have aesthetic appeal. Nature is full of visual objects, such as clouds and trees and mountains, as well as sounds, like the cacophony of excited birds, that have both structure and variety. The mathematics of chaos provides the tools for creating and describing such objects and sounds. Chaos theory reconciles our intuitive sense of free will with the deterministic laws of nature. However, it has an even deeper philosophical ramification. Not only do we have freedom to control our actions, but also the sensitivity to initial conditions implies that even our smallest act can drastically alter the course of history, for better or for worse. Like the butterfly flapping its wings, the results of our behavior are amplified with each day that passes, eventually producing a completely different world than would have existed in our absence! 2.2 Bucks and Bugs Enough philosophizing—it’s time to look at a specific example. This example requires some mathematics, but the equations are not difficult. The ideas and terminology are important for understanding what is to follow. Suppose you have some money in a bank account that provides interest, compounded yearly, and that you don’t make any deposits or withdrawals. Let’s let \\(X\\) represent the amount of money in your account. When the time comes for the bank to credit your interest, its computer does so by multiplying \\(X\\) by some number. With an interest rate of 10%, the number is 1.1, and your new balance is 1.1 X. If your balance in the nth year is \\(X_n\\) (where n is 1 after the first year, 2 after the second, and so forth), your balance in the year \\(n+1\\) is \\[ X_{n+1}=RX_n \\] where \\(R\\) is equal to 1.0 plus your interest rate. (\\(R\\) is 1.1 in this example.) You probably know that such compounding leads to exponential growth. In terms of the initial amount \\(X_0\\), the amount in your account after n years is \\[ X_n = X_0R^n \\] After 50 years at 10% yearly interest, you will have $117.39 for every dollar you initially invested. The bank can afford to do this only because of inflation and because money is loaned at an even higher interest rate. Equation 1A is applicable to more than compound interest. It’s how many of us have our salaries determined. It also describes population growth. Imagine some species of bug that lives for a season, lays its eggs, and then dies (thus avoiding the confusion of overlapping generations). The next year the eggs hatch, and the number of bugs is some constant R times the number in the previous year. If R is less than 1, the bugs die out over a number of years; and if R is greater than 1, their number grows exponentially. You also know that exponential growth cannot go on forever, whether it be bucks in the bank, bugs in the back yard or people on the planet. Eventually something happens, such as the depletion of resources, to slow down or even reverse growth. Mass starvation, disease, crime, and war are some of the mechanisms that limit unbridled human population growth. Thus we need to modify Equation 1A in some way if it is to model growth patterns in nature more closely. Perhaps the simplest modification is to multiply the right-hand side of Equation 1A by a term such as (1 - X), whose value approaches 1 as X gets smaller (much less than 1) but is less than 1 as X increases. Since the population dies abruptly as X approaches 1, we must think of X = 1 as representing some large number of dollars or bugs (say a million or a billion); otherwise we would never get very far! So our modified equation, called the logistic equation, is \\[ X_{n+1}=RX_n(1-X_n) \\] Now you’re going to get your first homework assignment. Take your pocket calculator and start with a small value of X, say 0.1. To reduce the amount of work you have to do, use a fairly large value of R, say 2, corresponding to a doubling every year. Run X through Equation 1C a few times and see what happens. This process is called iteration, and the successive values are called iterates. If you did it right, you should see that X grows rapidly for the first couple of steps, and then it levels off at a value of 0.5. The first few values should be approximately 0.1, 0.18, 0.2952, 0.4161, 0.4859, 0.4996, and 0.5. Compare your results with the unbounded growth of Equation 1A. You might have predicted the above result, if you had thought to set Xn+1 equal to Xn in Equation 1C and solved for Xn. This value is called a fixed-point solution of the equation, because if X ever has that value, it remains fixed there forever. Such a fixed-point solution is sometimes called a point attractor, because every initial value of X between 0 and 1 is attracted to the fixed point upon repeated iteration of Equation 1C. Try initial values of X = 0.2 and X = 0.8. A fixed point is also called a critical point, a singular point, or a singularity. If you’re curious, you might wonder what happens if you start with a value of X less than 0, such as -0.1, or greater than 1, such as 1.1. You should verify that the iterates are negative and that they get larger and larger, eventually approaching minus infinity. We say that the solution is unbounded and that it attracts to infinity. Thus the values of X = 0 and X = 1 are like a watershed. Between these values the solution is bounded, and outside these values it is unbounded. The region between X = 0 and X = 1 is called a basin of attraction because it resembles a bathroom basin in which drops of water find their way to the drain from wherever they start. X = 0 is also a fixed point, but it is unstable because values either slightly above or slightly below zero move away from zero. Such an unstable fixed point is sometimes called a repellor. Chaos can result when two or more repellors are present; the iterates then bounce back and forth like a baseball runner caught in a squeeze play. See what happens if you substitute X = 0 or X = 1 into the logistic equation. As a check on your calculations, or in case you didn’t do your homework, Table 1-1 shows the successive iterates of X for each of the cases we have discussed. An equation, such as the logistic equation, that predicts the next value of a quantity from the previous value is called an iterated map because it is like a road map in which each point on the earth is mapped to a corresponding point on a piece of paper. The logistic equation is a one-dimensional map because the various X values can be thought of as lying along a straight line that stretches from minus infinity to plus infinity. Each iteration of the map moves every point along the line to a new position on the line. For the example above with R = 2, all the points between X = 0 and X = 1 walk toward X = 0.5, where they stop and remain. Other points run faster and faster toward the end of the line that stretches to minus infinity. The logistic equation is an example of a quadratic iterated map, so called because if you multiply out the right-hand side of Equation 1C, it has not only a linear term RXn but also a quadratic (squared) term \\(-RX_n^2\\). Quadratic maps are noninvertable because you can find Xn+1 from Xn , but can’t go backward because there are two values of Xn that produce the same Xn+1, and there is no way of knowing from which it came. For example, Table 1-1 shows that X0 = 0.2 and X0 = 0.8 both produce X1 = 0.32. These are the two roots of the quadratic equation that you get if you try to solve for Xn in Equation 1C in terms of Xn+1. The graph of Xn+1 versus Xn is a curve called a parabola. Because a parabola is not a straight line, the map is said to be nonlinear. Chaos and strange attractors require nonlinearity. The interesting and surprising behavior of nonlinear iterated maps is the basis for much of this book. The first surprising result occurs if you iterate Equation 1C with R = 3.2 and an initial value of X in the range of 0 to 1. After a few iterations the solution will alternate between two values of approximately 0.5130 and 0.7995. This is called a period-2 limit cycle. Like the fixed point, the limit cycle is another type of simple attractor. It is sometimes called a periodic or cyclic attractor. It’s not hard to see how cyclic behavior might arise in nature. If the population of beetles grows too large, they deplete the plants on whom they depend for food. With too few plants, the beetles die out, allowing the number of plants to recover, leading to the next cycle of beetle growth, and so forth. Increase R a bit more to 3.5, and repeat the calculation. The result is a period 4 limit cycle with four values of approximately 0.5009, 0.8750, 0.3828, and 0.8269. If you keep increasing R by ever smaller amounts, the period of the limit cycle doubles repeatedly, finally reaching chaotic behavior (an infinite period) at about R = 3.5699456. This value is sometimes called the Feigenbaum point, after Mitchell J. Feigenbaum, a contemporary mathamatician who discovered many of the inter esting properties of one-dimensional maps. When chaos occurs, the successive iterates fluctuate in an apparently random and irreproducible manner. The chaotic behavior persists up to R = 4 except for an infinite number of small periodic windows. For R greater than 4, the solution is unbounded, and the iterates attract rapidly to minus infinity. The behavior described above can be summarized in a bifurcation diagram, as shown in Figure 1-1, in which the limiting iterated values of the logistic equation, after discarding the first few hundred iterates, are plotted for a range of R from 2 to 4. This plot is called the Feigenbaum diagram, and it resembles a tree on its side. (“Feigenbaum,” appropriately but coincidentally, is German for “fig tree.”) You see the fixed-point solution for R less than 3, the period-doubling route to chaos, and the periodic windows at large \\(R\\). The chaotic regions toward the right side of the figure are characterized by values of \\(X\\) that span a wide range and eventually fill the region densely with points. logistic.map &lt;- function(r, x, N, M){ ## r: bifurcation parameter ## x: initial value ## N: number of iteration ## M: number of iteration points to be returned z &lt;- 1:N z[1] &lt;- x for(i in c(1:(N-1))){ z[i+1] &lt;- r *z[i] * (1 - z[i]) } ## Return the last M iterations z[c((N-M):N)] } ## Set scanning range for bifurcation parameter r my.r &lt;- seq(2, 4, by=0.003) Orbit &lt;- sapply(my.r, logistic.map, x=0.1, N=1000, M=300) Orbit &lt;- as.vector(Orbit) r &lt;- sort(rep(my.r, 301)) plot(Orbit ~ r, pch=&quot;.&quot;) #data.frame(xn) %&gt;% ggplot(aes(x,y)) + geom_point() Each period doubling is called a bifurcation because a single solution splits into a pair of solutions. These splittings are called pitchfork bifurcations for obvious reasons. Note the period-3 window at about R = 3.84. The period-3 region begins abruptly when R is increased slightly from within the chaotic region to its left in what is called a tangent or saddle-node bifurcation. Careful inspection of the period-3 window shows that it also undergoes a period-doubling sequence at about R = 3.85. Solutions with every period can be found somewhere between R = 3 and R = 4. Successive period doublings occur with ever-increasing rapidity as one moves from left to right in Figure 1-1. The ratio of the width of each region to the width of the previous region approaches a constant equal to 4.669201660910…, called the Feigenbaum number. Even more remarkable is that this number arises in many different chaotic systems in nature as well as in the solutions of equations. The universality of the Feigenbaum number in chaos is reminiscent of the ubiquity of the number p in Euclidean geometry With R = 4 the solutions occupy the entire interval from X = 0 to X = 1. Eventually X takes on a value arbitrarily close to any point in that interval (a characteristic called topological transitivity). Curiously, however, infinitely many initial values of X don’t lead to a chaotic solution even for R = 4. For example \\(X_0 = 0.5\\) and \\(X_0 = 0.75\\) lead to unstable fixed points, while \\(X_0 = 0.345491...\\) and \\(X_0 = 0.904508...\\) produce an unstable period-2 limit cycle. By nstable we mean that if the initial values are wrong by even the slightest amount, successive iterates will wander ever farther away. Even though there are infinitely many nonchaotic initial values between zero and one, the chance that you will find one by randomly guessing is negligible. For every such value, there are infinitely many others that produce chaos. Such a seemingly paradoxical entity is an example of a Cantor set, named after the 19th century Russian-born German mathematician Georg Cantor who is often credited with developing a mathematically rigorous concept of infinity. A Cantor set contains infinitely many members (in fact, uncountably infinitely many), but its members represent a zero fraction of the total! For example, infinitely many points are required to cover completely the circumference of a circle, but this number of points doesn’t even begin to cover its interior. Such a collection (or set) of points, although infinite in number, is said to comprise a set of measure zero, because the points fill a negligible portion of the plane. An attractor is a set of measure zero, but its basin of attraction has a nonzero measure. Few people would have guessed that such complexity could arise from such underlying simplicity. Furthermore, the logistic equation is only the simplest of an endless variety of equations that can exhibit chaos. It is this dichotomy of simplicity and complexity that makes chaos beautiful to the mathematician and artist alike. In the bifurcation diagram of the logistic equation, we have something with aesthetic appeal, and it came from a simple quadratic equation! 2.3 The Butterfly Effect If our goal is to seek chaotic behavior in the solution of equations, we need a simple way to test for chaos. For this purpose we use the fact that chaotic processes exhibit extreme sensitivity to initial conditions, in contrast to regular processes in which different starting points usually converge to the same sequence of points on a simple attractor. Suppose we iterate the logistic equation with two initial values of \\(X\\) that differ by only a tiny amount. Think of these values as representing two states of the atmosphere that differ only by the flapping of the wings of a butterfly. If successive iterates are attracted to a fixed point as they are for \\(R = 2\\), the difference between the two solutions must get smaller and smaller as the fixed point is approached. A similar thing happens for a limit cycle. The difference between the two solutions will on average decrease exponentially. If the solution is chaotic, as is the logistic equation for R = 4, the successive iterates for the two cases initially on average get farther apart; the difference usually increases exponentially. If the difference doubles on average with every iteration, we say the Lyapunov exponent is 1. If it is reduced by half, we say the Lyapunov exponent is -1. The name comes from the late-19th-century Russian mathematician Aleksandr M. Lyapunov (sometimes transliterated Liapunov or Ljapunov). You can think of the Lyapunov exponent as the power of 2 by which the difference between two nearly equal X values changes on average for each iteration. Thus the difference between the values changes by an average of 2 L for each iteration. If L is negative, the solutions approach one another; if L is positive, we have sensitivity to initial conditions and hence chaos. One way to detect chaos is to iterate the equation with two nearly equal initial values and see if, after many iterations, the values are closer together or farther apart. Another way is to make use of a principle of calculus that says that the difference in the solutions after one iteration divided by the difference before the iteration, provided the difference is small, is equal to the derivative of the equation for the map, which for the logistic equation is \\[ \\frac{\\Delta X_{n+1}}{\\Delta X_n}=R(1-2X_n) \\] where \\(\\Delta X\\) is the difference between the two values of X. In Equation 1D, \\(\\Delta X_n\\) is the difference in the X values after n iterations, and \\(\\Delta X_{n+1}\\) is the difference after n+1 iterations. Since DX increases by the factor on the right of Equation 1D for each iteration, the proper way to calculate the average is to start with a value of 1 and multiply it repeatedly by the right-hand side of Equation 1D at each iteration, then divide the result by the number of iterations, and finally take the logarithm to the base 2 of the absolute value of the result to get the Lyapunov exponent. If you prefer an equation, the preceding description is equivalent to \\[ L=\\Sigma\\frac{\\log_2|R(1-2X_n)|}{N} \\] where the vertical bars mean that you are to disregard the sign of the quantity inside, and \\(\\Sigma\\) means to sum the quantity to its right from a value of \\(n = 1\\) to a value of \\(n = N\\), where N is some large number. The larger the value of \\(N\\), the more accurate the estimate of \\(L\\). Suppose you knew the value of X to within 0.01 for an iterated map with L = 1. After one iteration the uncertainty would be about 0.02, and after two iterations the uncertainty would be about 0.04, and so forth. After about seven iterations, the error would exceed 1, and your prediction would be totally worthless. If the X values are expressed as binary numbers, each iteration would result in throwing away the rightmost (least significant) binary digit (bit). Thus the units of L are bits per iteration. Sometimes L is expressed in terms of the natural logarithm (base e) rather than \\(log_2\\). The Lyapunov exponent is the rate at which information is lost when a map is iterated. It is as if a succession of cartographers each copied maps from one another, but every time one was copied it was only half as accurate as the previous one. If the original map were accurate to 1%, the next copy would be accurate to 2%, and the seventh generation copy would bear no relation to the original. If the Lyapunov exponent were -1, one bit of information would be gained at each iteration. Even a completely unknown initial condition would eventually be perfectly accurate as it approached the known fixed point or limit cycle. Unfortunately, negative Lyapunov exponents are not the rule in cartography; otherwise all our maps would be selfcorrecting! TODO: Create the lyapunov exponent lyap &lt;- function(a,trans=300,num=1000){ x0 &lt;- runif(1) for(time in 1:trans){ x1 &lt;- f(x0,a=a);x0 &lt;- x1 } sl &lt;- 0 for(time in 1:num){ x1 &lt;- f(x0,a=a);x0 &lt;- x1 sl &lt;- sl+log(abs(grad(f,x1,a=a))) } sl/num } a &lt;- seq(0.5,4,length=100) ly &lt;- sapply(a,lyap) plot(a,ly,t=&quot;l&quot;) Figure 1-2 shows the Lyapunov exponent for the logistic equation using values of R from 2 to 4. The Lyapunov exponent is 1.0 at \\(R = 4\\) because that value causes the interval of X from 0 to 1 to be mapped backed onto itself with a single fold at \\(X = 0.5\\). Thus information is lost at a rate of 1 bit per iteration, because each iterate has two possible predecessors. You can also see some of the periodic windows where L dips below zero toward the right edge of the plot. Also note that L is zero wherever a bifurcation occurs, for example at \\(R=2\\). At these points the solution is fraught with indecision over which branch to take, and the initial uncertainty persists forever, neither increasing nor decreasing. 2.4 The Computer Artist By now you have probably surmised that the operations we have described are best carried out by a computer. The equations are simple, but they must be applied repeatedly. This is precisely the kind of task at which computers excel. There are dozens of computer types and programming languages to choose from. Currently the most popular computers are those based on the IBM PC running the MS-DOS or IBM-DOS operating system (hereafter simply called DOS). The most widely available programming language is BASIC (Beginner’s All-purpose Symbolic Instruction Code), which usually comes bundled with the operating system software included with the computer. A version of BASIC called QBASIC has been included with DOS since version 5.0. BASIC may not be the most advanced computer language, but it is one of the easiest to learn and to use, its commandsare close to ordinary English, and it is more than adequate for our purposes. Furthermore, modern versions of BASIC compare favorably with the best of the other languages. The American National Standards Institute (ANSI) has established a standard for the BASIC language, but it is somewhat limited, and most versions of BASIC have many additions and embellishments. We will intentionally use a primitive dialect to ensure compatibility with most modern implementations and to simplify the translation into incompatible versions. In particular, the programs in this book should run without modification under Microsoft BASICA, GW-BASIC, QBASIC, QuickBASIC, VisualBASIC for MS-DOS; Borland International Turbo BASIC (no longer available); and Spectra Publishing PowerBASIC on IBM PCs or compatibles. You will be happiest using a modern compiled BASIC such as VisualBASIC or PowerBASIC on a fast computer with a math coprocessor. Appendix C includes information on translating the computer programs into other, partially incompatible dialects of BASIC, as well as source code for use with VisualBASIC for Windows and Microsoft QuickBASIC for the Macintosh. Appendix D contains a translation into Microsoft QuickC. The BASIC programs use line numbers, which have been obsolete since the mid-1980s, but they are harmless, and they provide a convenient way to reference lines of the program and to indicate where in the program a change is to be made. If you follow sequentially through this book, you will need to add and change a only few lines of the program as you meet each new idea. Your program will gradually grow more versatile as you work through the book. In the end you will have a powerful program that can reproduce all the examples in this book as well as an endless variety of new ones. Hence you should avoid the temptation to eliminate or to change the line numbers, at least until you have a fully functional program. You may prefer to jump to Appendix B where you will find the complete final program, which is also provided on the accompanying disk along with source listings in BASIC, Microsoft QuickC, Borland Turbo C++ and a ready-to-run executable version of the program. If you are an experienced programmer, you might ridicule some of the quaint program listings. Many powerful programming structures such as block IF statements, DO LOOPs, and callable subroutines with local variables that produce beautifully structured programs are now standard, but they have been avoided to allow backwards compatibility with more primitive versions of BASIC. They also often impose a small speed penalty. The dreaded GOTO statement has been used primarily to bypass blocks of code in deference to BASIC versions that don’t support block IF statements. Lines of the program that are bypassed by a GOTO are usually indented. Blocks of the program contained within FOR…NEXT loops have also been indented. In the interest of structure and simplicity, the programs have been written using numerous small modular subroutines, each with a single entry point beginning with a comment line, and a single exit point containing a RETURN statement, albeit with global variables. The individual subroutines are separated with blank lines. It should be relatively easy for an experienced programmer to rewrite the program in a more modern format. The program listing PROG01 iterates the logistic equation for R = 4 with an initial value of X = 0.05 and makes a graph of each iterate versus its predecessor. The program looks more complicated than it actually is because the various operations have been relegated to subroutines to provide a template for the more versatile cases to follow. data &lt;- seq(-10,10,1) parabola &lt;- function(x) {4*x*(1-x)} ly &lt;- sapply(data,parabola) plot(data, ly,t = &quot;l&quot;) 1000 REM LOGISTIC EQUATION 1010 DEFDBL A-Z ’Use double precision 1030 SM% = 12 ’Assume VGA graphics 1190 GOSUB 1300 ’Initialize 1200 GOSUB 1500 ’Set parameters 1210 GOSUB 1700 ’Iterate equations 1220 GOSUB 2100 ’Display results 1230 GOSUB 2400 ’Test results 1240 ON T% GOTO 1190, 1200, 1210 1250 CLS 1260 END 1300 REM Initialize 1320 SCREEN SM% ’Set graphics mode 1350 WINDOW (-.1, -.1)-(1.1, 1.1) 1360 CLS 1420 RETURN 1500 REM Set parameters 1510 X = .05 ’Initial condition 1560 R = 4 ’Growth rate 1570 T% = 3 1590 LINE (-.1, -.1)-(1.1, 1.1), , B 1630 RETURN 1700 REM Iterate equations 1720 XNEW = R * X * (1 - X) 2030 RETURN 2100 REM Display results 2300 PSET (X, XNEW) ’Plot point on screen 2320 RETURN 2400 REM Test results 2490 IF LEN(INKEY$) THEN T% = 0 ’Respond to user key stroke 2510 X = XNEW ’Update value of X 2550 RETURN If, when you first run the program, your computer reports an error, it is probably in one of the following lines: Line 1010: Be sure your version of BASIC supports double-precision (four-byte) floating-point variables. If it doesn’t, you may omit this line, but then you probably will have to change the 4 in line 1560 to 3.99999 to avoid overflow resulting from round-off errors. With modern versions of BASIC and a computer with a math coprocessor, there is no penalty, and considerable advantage, in using double precision. Because of the finite precision of computer arithmetic, all cases will eventually repeat, but with double precision the average number of iterations required before this happens is acceptably large. Line 1320: Either your version of BASIC doesn’t require this command or your computer or compiler doesn’t support VGA graphics. Try reducing the 12 in line 1030 to a lower number until you find one that works. If none works, try eliminating line 1320 altogether. Line 1350: The WINDOW command defines the coordinates of the lower-left and upper-right corners of the graphics window for subsequent PSET and LINE commands. If your version of BASIC doesn’t support this command, you must delete this line and convert all the parameters in the PSET and LINE commands to address screen pixels. In this case try replacing line 2300 with PSET (200 * X, 200 - 200 * XNEW). One advantage of using the WINDOW command is that when a version of BASIC comes along that supports higher screen resolutions, the program can be easily recompiled to take advantage of it. Other errors: Look carefully for typographical errors, or consult your BASIC manual to determine compatibility. The correct program should produce a plot of the logistic parabola, as shown in Figure 1-3. Try different initial values of X (line 1510) and different values of R (line 1560) to confirm the behavior predicted for the logistic equation. TODO: Insert parabola from PROG01 The logistic parabola comes from a chaotic solution, but it doesn’t look very complicated, and it would hardly qualify as art. With one small change we can make things more interesting and, at the same time, illustrate sensitivity to initial conditions. Instead of plotting each iterate versus its immediate predecessor, we could plot it versus its second or third or fourth predecessor. Let’s save the last 500 iterates and provide the option to plot X versus any one of them The changes that you need to make in the program PROG01 to accomplish this are shown in the listing PROG02. You can either go through the program and change or add lines as necessary or type the listing and save it in ASCII format and then use the MERGE command supported by many (mostly old) versions of BASIC to update the previous version of the program. 1000 REM LOGISTIC EQUATION (5th Previous Iterate) 1020 DIM XS(499) 1040 PREV% = 5 ’Plot versus fifth previous iterate 1580 P% = 0 2210 XS(P%) = X 2220 P% = (P% + 1) MOD 500 2230 I% = (P% + 500 - PREV%) MOD 500 2300 PSET (XS(I%), XNEW) ’Plot point on screen If you set PREV% = 1 in line 1040, the result is the same as for PROG01. However, if you set PREV% equal to 2, you see the logistic parabola change into a curve with two humps. Each time you increase PREV% by 1, you double the number of humps in the curve. Thus PREV% = 5 results in 16 oscillations, as shown in Figure 1-4. TODO Insert picture her Figure 1-4 provides a good graphical illustration of the sensitivity to initial conditions. The horizontal axis represents all possible initial conditions from zero to one. The vertical axis shows the value from zero to one corresponding to each initial condition after five iterations. It’s not hard to see that two nearby points on the horizontal axis usually translate into two very different values along the vertical axis after five iterations. Try using PREV% = 10, and convince yourself that information about the initial condition is almost completely lost after ten iterations. This exercise provides a good insight into the way a strange attractor is formed geometrically. The logistic parabola, which began as a line (a onedimensional object), is stretched and folded with each iteration, eventually filling the entire plane (a two-dimensional object) after many iterations. Perhaps it reminds you of those taffy machines that repeatedly stretch and fold the taffy, causing two nearby specks in the taffy after a while to be nowhere near one another. On average the distance between the specks initially increases at an exponential rate. You should be able to think of many other examples of sensitivity to initial conditions. When you stir your coffee to mix in the cream, you’re relying on a chaotic process. Two sticks dropped into the water close together just above a waterfall eventually end up far apart. Try laying two identical garden hoses side by side, and turn on the water in each one at the same time without holding the ends. Chaotic processes are all around us. Their mathematical solutions usually produce chaotic strange attractors, whose diversity and beauty we are about to explore. "],
["wiggly-lines.html", "3 Wiggly Lines 3.1 More Knobs to Twiddle 3.2 Randomness and Pseudorandomness 3.3 What’s in a Name? 3.4 The Computer Search 3.5 Making Music", " 3 Wiggly Lines In this chapter we will teach the computer to search for chaotic solutions of simple equations with a single variable. The solutions are segments of lines, but the lines can wiggle in an incredibly complicated manner. 3.1 More Knobs to Twiddle The logistic equation (Equation 1C) is an example of a dynamical system. Such systems are described by deterministic initial-value equations. This particular system has a single parameter R whose value determines the solution’s behavior for all initial values of X within the basin of attraction. This parameter is like a knob on a radio or on a stove that you can turn up or down to control the sound emitted by the radio or the convection in a pot of boiling soup. You can do a simple experiment to observe the period-doubling route to chaos. Go into your bathroom or kitchen and turn on the tap, only slightly, to produce a regular periodic pattern of drips. Now slowly open the tap until the pattern becomes chaotic. Just before the onset of chaos, if you are sufficiently careful and patient, you should observe one or more period doublings where the sound changes to something like “drip drip—drip drip—drip drip.” The knob that controls the flow rate corresponds to the parameter R in the logistic equation. The dripping faucet has been extensively studied by Robert Shaw and discussed at length in his book The Dripping Faucet as a Model Chaotic System. Usually a dynamical system has more than one knob. Your kitchen faucet probably has independent control of the flow rate and the temperature of the water. With more knobs, you might expect to increase the variety of ways the system can behave. Such knobs are called control parameters. The formula for the most general one-dimensional quadratic iterated map is \\[ X_{n+1}=a_1+a_2x_n+a_3x_{n_2} \\] where a1, a2, and a3 are three control parameters. By exploring all combinations of their values, we expect eventually to observe every possible peculiar solution that the equation can have. You might think that the initial condition \\(X_0\\) is a fourth knob, but if the system is chaotic, the solution is generally a strange attractor, and all initial conditions within the basin of attraction look the same after many iterations. Of course there is no guarantee that a particular choice of \\(X_0\\) lies within the basin, but values of X close to zero are within the basin about half the time, and there are so many chaotic solutions over the range of the other three parameters that we can well afford to discard half of them. The search for strange attractors proceeds as follows. Choose values for \\(a_1\\), \\(a_2\\), and \\(a_3\\) arbitrarily. Start with a value of X0 near zero. Iterate Equation 2A repeatedly until the solution either exceeds some large number, in which case it is presumably unbounded, or until the Lyapunov exponent becomes small or negative, in which case the solution is probably a fixed point or limit cycle. In either event, choose a different combination of a1, a2, and a3, and start over. If, after a few thousand iterations, the solution is bounded (X is not enormous) and the Lyapunov exponent is positive, then it is likely that you have found a strange attractor. 3.2 Randomness and Pseudorandomness To choose values of a1, a2, and a3 , we can use the random-number generator provided with most computer languages. The random numbers thus produced are usually uniformly distributed between zero and one. You may wonder how a computer, the epitome of determinism, could ever produce a random number. This question deserves a digression because the answer provides yet another example of the very issues we have been discussing. One way to produce a random number is to start with a value of X (the seed) between zero and one and iterate the logistic equation with R = 4 a few dozen times. The result is a new number in the range of zero to one that is related to the seed in a complicated and sensitive way. This number is then used as the seed for the next random number, which is produced in the same way. A given seed will produce the same sequence of random numbers, but the sequence may not be the same on different computers or with different languages or even with different versions of the same language because of the way the numbers are rounded. However, this method of producing random numbers is not optimal. First, the numbers are not uniformly distributed over the range. They tend to cluster near zero and one as the darkness of the right-hand side of Figure 1-1 suggests. Also, multiplying a non-integer number by itself many times is a relatively slow process on a computer. Instead, computers usually get their random numbers using the linear congruential method: \\[ X_{n+1}=(aX_n+b)\\mod c \\] In the mod (modulus) operation, the quantity to the left of the \\(\\mod (aXn + b)\\) is divided by the quantity to its right (c), and the remainder is kept rather than the quotient. All the quantities in Equation 2B are integers. The constants a, b, and c are carefully chosen to maximize the number of steps required for the sequence to repeat, which in any case can never exceed c. The numbers are uniformly distributed from zero to c - 1, but they can be transformed to the range zero to one by simply dividing Xn+1 by c. The numbers appear to be random, but since they are produced using a deterministic procedure, they are often called pseudorandom. Equation 2B is another example of a one-dimensional chaotic map, which is related to the shift map. Truly random numbers should satisfy infinitely many conditions. Not only must the numbers be uniform over the interval, but there should be no detectable relation between the numbers and any of their predecessors. In particular, the sequence should repeat only after a very large number of steps. Most randomnumber generators are deficient in certain ways. For example, the random numbers produced by Microsoft QBASIC 1.0, QuickBASIC 4.5, and VisualBASIC for DOS 1.0 repeat after 16,777,216 steps, and this number is too small for some of our purposes. The situation can be greatly improved by shuffling the numbers. Suppose we maintain a table of a hundred or so random numbers. When we want one, we randomly take an entry from the table and replace it with a new random number. With this simple modification, the pseudorandom numbers generated by the computer are sufficiently random for our purpose You should always remember that the sequence of random numbers generated by a digital computer will eventually repeat. You must take care to ensure that over the duration of a calculation, such a repetition does not occur. You must also reseed the random-number generator using a truly random seed, such as one based on the time of day the program is started, if you are to avoid repeating the same sequence each time you run the program. 3.3 What’s in a Name? When we begin to choose random values for the coefficients a1, a2, and a3, we are immediately confronted with two issues. The first is the range of values that the coefficients may have, and the second is the amount by which two values of a coefficient must differ to produce attractors that are visibly different. We can address the first issue by referring to the logistic equation (Equation 1C). When the value of R is too small (less than about 3.5), there are no chaotic solutions, and when the value of R is too large (greater than 4), all the solutions are unbounded. A similar situation occurs for the more general one-dimensional quadratic map in Equation 2A. Thus we want to limit the coefficients to values whose magnitudes (positive or negative) are of order unity. That is, 0.1 is probably too small a value and 10 is probably unnecessarily large. This assumption can be verified by numerical experiment. The second issue requires a subjective judgment of how dissimilar two attractors must look before we consider them to be different. In practice, a change in one of the coefficients by an amount of order 0.1 generally produces an object that is noticeably different. If we let each coefficient take on values ranging from -1.2 to 1.2 in steps of 0.1, we will have 25 possible values. We can associate each with a letter of the alphabet, A through Y, and have a convenient way to catalog and replicate the attractors. Limiting the coefficients to 25 values may seem excessively restrictive, but since there are three coefficients for one-dimensional quadratic maps, there are 253 or 15,625 different combinations. The coefficients that correspond to the logistic equation with R = 4 are a1 = 0, a2 = 4, and a3 = -4, and they fall outside the range of -1.2 to 1.2. Thus for some purposes, it is convenient to take a larger range. A convenient way to extend the range is to use the ASCII (American Standard Code for Information Interchange) character set summarized in Table 2-1. ASCII codes from 0 to 31 are reserved for control codes—things like backspace, carriage return, and line feed. Codes from 128 to 255 can also be used, but there is no universal character set associated with them. By making use of all the ASCII characters from 0 to 255, we can accommodate coefficients in the range of -7.7 to 17.8. The characters listed in the table will suffice for most of our needs, however. With such a coding scheme, we can represent each attractor by a sequence of characters, with each character corresponding to one of the coefficients. The sequence can be thought of as the name of the attractor. We preface the name with a character that indicates the type of equation. Let’s use the letter A to represent one-dimensional quadratic maps. Thus the logistic equation coded in this way is AMu%. Note that the letters in the name are case sensitive (u and U are different), so you should be careful when typing them. Such names may look strange, which is perhaps appropriate for strange attractors, and you shouldn’t try to pronounce them! However, they do provide a convenient and compact method for saving everything you need to reproduce an attractor. 3.4 The Computer Search Before embarking on a search for strange attractors, we need to generalize the formula given in Equation 1E for the Lyapunov exponent of the logistic equation. The generalization is easily obtained using differential calculus, and the result is \\[ L = \\frac{\\Sigma\\log_2|a_2+2_{a_3}X_n|}{N} \\] 1000 REM ONE-D MAP SEARCH 1020 DIM XS(499), A(504), V(99) 1050 NMAX = 11000 ’Maximum number of iterations 1160 RANDOMIZE TIMER ’Reseed random-number generator 1360 CLS : LOCATE 13, 34: PRINT “Searching…” 1560 GOSUB 2600 ’Get coefficients 1580 P% = 0: LSUM = 0: N = 0: NL = 0 1590 XMIN = 1000000!: XMAX = -XMIN 1720 XNEW = A(1) + (A(2) + A(3) * X) * X 2020 N = N + 1 2110 IF N &lt; 100 OR N &gt; 1000 THEN GOTO 2200 2120 IF X &lt; XMIN THEN XMIN = X 2130 IF X &gt; XMAX THEN XMAX = X 2140 YMIN = XMIN: YMAX = XMAX 2200 IF N = 1000 THEN GOSUB 3100 ’Resize the screen 2250 IF N &lt; 1000 OR XS(I%) &lt;= XL OR XS(I%) &gt;= XH OR XNEW &lt;= XL OR XNEW &gt;= XH THEN GOTO 2320 2410 IF ABS(XNEW) &gt; 1000000! THEN T% = 2 ’Unbounded 2430 GOSUB 2900 ’Calculate Lyapunov exponent 2460 IF N &gt;= NMAX THEN T% = 2 ’Strange attractor found 2470 IF ABS(XNEW - X) &lt; .000001 THEN T% = 2 ’Fixed point 2480 IF N &gt; 100 AND L &lt; .005 THEN T% = 2 ’Limit cycle 2600 REM Get coefficients 2660 CODE$ = “A” 2680 M% = 3 2690 FOR I% = 1 TO M% ’Construct CODE$ 2700 GOSUB 2800 ’Shuffle random numbers 2710 CODE$ = CODE$ + CHR\\((65 + INT(25 * RAN)) 2720 NEXT I% 2730 FOR I% = 1 TO M% &#39;Convert CODE\\) to coefficient values 2740 A(I%) = (ASC(MID\\((CODE\\), I% + 1, 1)) - 77) / 10 2750 NEXT I% 2760 RETURN 2800 REM Shuffle random numbers 2810 IF V(0) = 0 THEN FOR J% = 0 TO 99: V(J%) = RND: NEXT J% 2820 J% = INT(100 * RAN) 2830 RAN = V(J%) 2840 V(J%) = RND 2850 RETURN 2900 REM Calculate Lyapunov exponent 2910 DF = ABS(A(2) + 2 * A(3) * X) 3030 IF DF &gt; 0 THEN LSUM = LSUM + LOG(DF): NL = NL + 1 3040 L = .721347 * LSUM / NL 3070 RETURN 3100 REM Resize the screen 3120 IF XMAX - XMIN &lt; .000001 THEN XMIN = XMIN - .0000005: XMAX = XMAX + .0000005 3130 IF YMAX - YMIN &lt; .000001 THEN YMIN = YMIN - .0000005: YMAX = YMAX + .0000005 3160 MX = .1 * (XMAX - XMIN): MY = .1 * (YMAX - YMIN) 3170 XL = XMIN - MX: XH = XMAX + MX: YL = YMIN - MY: YH = YMAX + MY 3180 WINDOW (XL, YL)-(XH, YH): CLS 3310 LINE (XL, YL)-(XH, YH), , B 3460 RETURN Here are six points to note about PROG03: The maximum number of iterations (NMAX in line 1050) has been set arbitrarily to 11,000. This is the number of iterations after which a strange attractor is assumed to have been found if the magnitude of X never exceeded one million and the Lyapunov exponent is positive (actually greater than 0.005). You can decrease NMAX to speed the rate at which attractors are found, or you can increase NMAX if you have a very fast computer or want to give the displays more time to develop. The number of iterations is a parameter that you can adjust for the most visually appealing result. Most of the figures in this book were made with NMAX set at between about 500,000 and 10 million, and they required between about a minute and an hour to produce. The seed for the random-number generator is taken in line 1160 as the number of seconds lapsed since midnight (TIMER). This choice ensures that a new sequence of random numbers is produced each time the program is run, except in the unlikely event that it is run at exactly the same time each day After 1000 iterations (line 2200), the screen is resized and erased by the subroutine in lines 3100 through 3460 using the minimum and maximum values of X between the 100th and 1000th iteration, allowing a 10% border around the attractor. To save time, the difference between each value of X and its predecessor is evaluated in line 2470, and if the difference is less than one millionth, the solution is assumed to be a fixed point even if the Lyapunov exponent is still positive. The Lyapunov exponent is not used as a criterion until after 100 iterations (line 2480) to ensure that its value is reasonably accurate. The coefficients of the equation are chosen in line 2710 using random numbers that have been shuffled by the subroutine in lines 2800 through 2850 to minimize the chance of repeating the same search sequence. The criterion for detecting a strange attractor is somewhat subjective. There will always be borderline cases for which no amount of computing will suffice to distinguish between a strange attractor and a periodic solution with a very long period. However, our interest here is in finding visually interesting attractors quickly, and so we can afford to make occasional mistakes. Such mistakes account for only a small fraction of cases. Of the 15,625 combinations of coefficients, exactly 364 (2.3%) are chaotic by these criteria. Some of the more visually interesting ones are shown in Figures 2-1 through 2-4, in which the values are plotted versus their fifth previous iterate. For each case, the code and the Lyapunov exponent are shown at the top of the graph. One-dimesnsional quadratic map AXBH F = 0.46 L = 0.06 One - dimensional quadratic map ABDU f = 0.07 L = 0.44 One-dimensional quadratic map ACAV F = 0.80 L = 0.70 One-dimensional quadratic map AXDA F = 0.86 L = 0.89 3.5 Making Music "],
["pieces-of-planes.html", "4 Pieces of Planes 4.1 Quadratic Maps in Two Dimensions 4.2 The Butterfly Effect Revisited 4.3 Searching the Plane 4.4 The Fractal Dimension 4.5 Higher-Order Disorder 4.6 Strange Attractor Planets 4.7 Designer Plaids 4.8 Strange Attractors that Don’t 4.9 A New Dimension in Sound", " 4 Pieces of Planes 4.1 Quadratic Maps in Two Dimensions 4.2 The Butterfly Effect Revisited 4.3 Searching the Plane 4.4 The Fractal Dimension 4.5 Higher-Order Disorder 4.6 Strange Attractor Planets 4.7 Designer Plaids 4.8 Strange Attractors that Don’t 4.9 A New Dimension in Sound "],
["attractors-of-depth.html", "5 Attractors of Depth 5.1 Projections 5.2 Shadows 5.3 Bands 5.4 Colors 5.5 Characters 5.6 Anaglyphs 5.7 Stereo Pairs ~ Stereo Pairs 5.8 Slices", " 5 Attractors of Depth 5.1 Projections 5.2 Shadows 5.3 Bands 5.4 Colors 5.5 Characters 5.6 Anaglyphs 5.7 Stereo Pairs ~ Stereo Pairs 5.8 Slices "],
["the-fourth-dimension.html", "6 The Fourth Dimension 6.1 Hyperspace 6.2 Projections 6.3 Other Display Techniques 6.4 Writing on the Wall 6.5 Murals and Movies 6.6 Search and Destroy", " 6 The Fourth Dimension 6.1 Hyperspace 6.2 Projections 6.3 Other Display Techniques 6.4 Writing on the Wall 6.5 Murals and Movies 6.6 Search and Destroy "],
["fields-and-flows.html", "7 Fields and Flows 7.1 Beam Me Up Scotty! 7.2 Professor Lorenz and Dr. Rossler 7.3 Finite Differences 7.4 Flows in Four Dimensions 7.5 Strange Attractors that Aren’t 7.6 Doughnuts and Coffee Cups", " 7 Fields and Flows 7.1 Beam Me Up Scotty! 7.2 Professor Lorenz and Dr. Rossler 7.3 Finite Differences 7.4 Flows in Four Dimensions 7.5 Strange Attractors that Aren’t 7.6 Doughnuts and Coffee Cups "],
["further-fascinating-functions.html", "8 Further Fascinating Functions 8.1 Steps and Tents 8.2 ANDs and ORs 8.3 Roots and Powers 8.4 Sines and Cosines 8.5 Webs and Wreaths 8.6 Swings and Springs 8.7 Roll Your Own", " 8 Further Fascinating Functions 8.1 Steps and Tents 8.2 ANDs and ORs 8.3 Roots and Powers 8.4 Sines and Cosines 8.5 Webs and Wreaths 8.6 Swings and Springs 8.7 Roll Your Own "],
["epilogue.html", "9 Epilogue 9.1 How Common is Chaos? 9.2 But is it Art? 9.3 Can Computers Critique Art? 9.4 What’s Left to Do? 9.5 What Good is It?", " 9 Epilogue 9.1 How Common is Chaos? 9.2 But is it Art? 9.3 Can Computers Critique Art? 9.4 What’s Left to Do? 9.5 What Good is It? "],
["appendix-a.html", "10 Appendix A", " 10 Appendix A "],
["appendix-b.html", "11 Appendix B", " 11 Appendix B "],
["appendix-c.html", "12 Appendix C", " 12 Appendix C "],
["appendix-d.html", "13 Appendix D", " 13 Appendix D #include &lt;dos.h&gt; #include &lt;stdio.h&gt; #include &lt;graph.h&gt; #include &lt;math.h&gt; int PREV, OMAX, D, ODE, SND, PJT, TRD, FTH, SAV, T, WID, QM, P, TWOD; int M, I, I1, I2, O, I3, I4, I5, J, WH, FREQ, C4, NC, C, RD, CY, BK; int COLR[16]; char CODE[515], Q; char FAV[9] = “XDATA.DAT”; double NMAX, EPS, TWOPI, SEG, NE, X, Y, Z, W, XE, YE, ZE, WE, LSUM, N, NL; double N1, N2, XMIN, XMAX, YMIN, YMAX, ZMIN, ZMAX, WMIN, WMAX, XNEW, YNEW; double ZNEW, WNEW, XP, YP, RAN, XSAVE, YSAVE, ZSAVE, WSAVE, DLX, DLY, DLZ; double DLW, DL2, DF, RS, L, MX, MY, XL, XH, YL, YH, XA, YA, ZA, TT, PT, TIA; double XZ, YZ, DUR, D2MAX, DX, DY, DZ, DW, D2, F, TH, PH, XRT, XLT, HSF, AL; double SINAL, COSAL, DUM, SW, SH; double XS[500], YS[500], ZS[500], WS[500], A[505], V[100], XY[5], XN[5]; union REGS regs; FILE F1, F2, *F3; main() { PREV = 5; /* Plot versus fifth previous iterate / NMAX = 11000; / Maximum number of iterations / OMAX = 5; / Maximum order of polynomial / D = 2; / Dimension of system / EPS = .1; / Step size for ODE / ODE = 0; / System is map / SND = 0; / Turn sound off / PJT = 0; / Projection is planar / TRD = 1; / Display third dimension as shadow / FTH = 2; / Display fourth dimension as colors / SAV = 0; / Don’t save any data / TWOPI = 6.28318530717959; / A useful constant (2 pi) / srand(time()); / Reseed random-number generator / fun4200(); / Display menu screen / T = 1; if (Q == ‘X’) T = 0; / Exit immediately on command / while (T) { switch (T) { case 1: fun1300(); / Initialize / case 2: fun1500(); / Set parameters / case 3: fun1700(); / Iterate equations / case 4: fun2100(); / Display results / case 5: fun2400(); / Test results */ } } _clearscreen(_GCLEARSCREEN); /* Erase screen */ _setvideomode(_DEFAULTMODE); /* and restore video mode / } fun1300() / Initialize */ { _setvideomode(_VRES16COLOR); /* Assume VGA graphics / WID = 80; / Number of text columns */ _clearscreen(_GCLEARSCREEN); _settextposition(13, WID / 2 - 6); printf(“Searching…”); fun5600(); /* Set colors */ if (QM == 2) { NE = 0; fclose(F1); F1 = fopen(“SA.DIC”, “a”); fclose(F1); F1 = fopen(“SA.DIC”, “r”); } } fun1500() /* Set parameters / { X = .05; / Initial condition / Y = .05; Z = .05; W = .05; XE = X + .000001; YE = Y; ZE = Z; WE = W; fun2600(); / Get coefficients */ T = 3; P = 0; LSUM = 0; N = 0; NL = 0; N1 = 0; N2 = 0; XMIN = 1000000; XMAX = -XMIN; YMIN = XMIN; YMAX = XMAX; ZMIN = XMIN; ZMAX = XMAX; WMIN = XMIN; WMAX = XMAX; TWOD = _rotl(1, D); } fun1700() /* Iterate equations / { if (ODE &gt; 1) fun6200(); / Special function / else { M = 1; XY[1] = X; XY[2] = Y; XY[3] = Z; XY[4] = W; for (I = 1; I &lt;= D; I++) { XN[I] = A[M]; M = M + 1; for (I1 = 1; I1 &lt;= D; I1++) { XN[I] = XN[I] + A[M] XY[I1]; M = M + 1; for (I2 = I1; I2 &lt;= D; I2++) { XN[I] = XN[I] + A[M] * XY[I1] * XY[I2]; M = M + 1; for (I3 = I2; O &gt; 2 &amp;&amp; I3 &lt;= D; I3++) { XN[I] = XN[I] + A[M] * XY[I1] * XY[I2] * XY[I3]; M = M + 1; for (I4 = I3; O &gt; 3 &amp;&amp; I4 &lt;= D; I4++) { XN[I] = XN[I] + A[M] * XY[I1] * XY[I2] * XY[I3] * XY[I4]; M = M + 1; for (I5 = I4; O &gt; 4 &amp;&amp; I5 &lt;= D; I5++) { XN[I] = XN[I] + A[M] * XY[I1] * XY[I2] * XY[I3] * XY[I4] * XY[I5]; M = M + 1; }}}}} if (ODE == 1) XN[I] = XY[I] + EPS * XN[I]; } XNEW = XN[1]; YNEW = XN[2]; ZNEW = XN[3]; WNEW = XN[4]; } N = N + 1; M = M - 1; } fun2100() /* Display results / { if (N &gt;= 100 &amp;&amp; N &lt;= 1000) { if (X &lt; XMIN) XMIN = X; if (X &gt; XMAX) XMAX = X; if (Y &lt; YMIN) YMIN = Y; if (Y &gt; YMAX) YMAX = Y; if (Z &lt; ZMIN) ZMIN = Z; if (Z &gt; ZMAX) ZMAX = Z; if (W &lt; WMIN) WMIN = W; if (W &gt; WMAX) WMAX = W; } if ((int)N == 1000) fun3100(); / Resize the screen / XS[P] = X; YS[P] = Y; ZS[P] = Z; WS[P] = W; P = (P + 1) % 500; I = (P + 500 - PREV) % 500; if (D == 1) { XP = XS[I]; YP = XNEW; } else { XP = X; YP = Y; } if (N &gt;= 1000 &amp;&amp; XP &gt; XL &amp;&amp; XP &lt; XH &amp;&amp; YP &gt; YL &amp;&amp; YP &lt; YH) { if (PJT == 1) fun4100(); / Project onto a sphere / if (PJT == 2) fun6700(); / Project onto a horizontal cylinder / if (PJT == 3) fun6800(); / Project onto a vertical cylinder / if (PJT == 4) fun6900(); / Project onto a torus / fun5000(); / Plot point on screen / if (SND == 1) fun3500(); / Produce sound / } } fun2400() / Test results / { if (fabs(XNEW) + fabs(YNEW) + fabs(ZNEW) + fabs(WNEW) &gt; 1000000) T = 2; if (QM != 2) { / Speed up evaluation mode / fun2900(); / Calculate Lyapunov exponent / fun3900(); / Calculate fractal dimension / if (QM == 0) { / Skip tests unless in search mode / if (N &gt;= NMAX) { / Strange attractor found / T = 2; fun4900(); / Save attractor to disk file SA.DIC / } if (fabs(XNEW - X) + fabs(YNEW - Y) + fabs(ZNEW - Z) + fabs(WNEW - W) &lt; .000001) T = 2; if (N &gt; 100 &amp;&amp; L &lt; .005) T = 2; / Limit cycle / } } if (kbhit()) Q = getch(); else Q = 0; if (Q) fun3600(); / Respond to user command / if (SAV &gt; 0) if (N &gt; 1000 &amp;&amp; N &lt; 17001) fun7000(); / Save data / X = XNEW; / Update value of X / Y = YNEW; Z = ZNEW; W = WNEW; } fun2600() / Get coefficients / { if (QM == 2) { / In evaluate mode / fgets(CODE, 515, F1); if (feof(F1)) { QM = 0; fun6000(); / Update SA.DIC file */ } else { fun4700(); /* Get dimension and order / fun5600(); / Set colors / } } if (QM == 0) { / In search mode / O = 2 + (int)floor((OMAX - 1) (float)rand() / 32768.0); CODE[0] = 59 + 4 * D + O + 8 * ODE; if (ODE &gt; 1) CODE[0] = 87 + ODE; fun4700(); /* Get value of M / for (I = 1; I &lt;= M; I++) { / Construct CODE / fun2800(); / Shuffle random numbers / CODE[I] = 65 + (int)floor(25 RAN); } CODE[M + 1] = 0; } for (I = 1; I &lt;= M; I++) { /* Convert CODE to coefficient values / A[I] = (CODE[I] - 77) / 10.0; } } fun2800() / Shuffle random numbers / { if (V[0] == 0) for (J = 0; J &lt;= 99; J++) {V[J] = (float)rand() / 32768.0;} J = (int)floor(100 RAN); RAN = V[J]; V[J] = (float)rand() / 32768.0; } fun2900() /* Calculate Lyapunov exponent / { XSAVE = XNEW; YSAVE = YNEW; ZSAVE = ZNEW; WSAVE = WNEW; X = XE; Y = YE; Z = ZE; W = WE; N = N - 1; fun1700(); / Reiterate equations / DLX = XNEW - XSAVE; DLY = YNEW - YSAVE; DLZ = ZNEW - ZSAVE; DLW = WNEW - WSAVE; DL2 = DLX DLX + DLY * DLY + DLZ * DLZ + DLW * DLW; if (DL2 &gt; 0) { /* Check for division by zero / DF = 1E12 DL2; RS = 1 / sqrt(DF); XE = XSAVE + RS * (XNEW - XSAVE); YE = YSAVE + RS * (YNEW - YSAVE); ZE = ZSAVE + RS * (ZNEW - ZSAVE); WE = WSAVE + RS * (WNEW - WSAVE); XNEW = XSAVE; YNEW = YSAVE; ZNEW = ZSAVE; WNEW = WSAVE; LSUM = LSUM + log(DF); NL = NL + 1; L = .721347 * LSUM / NL; if (ODE == 1 || ODE == 7) L = L / EPS; if (N &gt; 1000 &amp;&amp; (int)N % 10 == 0) { _settextposition(1, WID - 4); printf(“%5.2f”, L); } } } fun3100() /* Resize the screen */ { _setcolor(WH); if (D == 1) { YMIN = XMIN; YMAX = XMAX; } if (XMAX - XMIN &lt; .000001) { XMIN = XMIN - .0000005; XMAX = XMAX + .0000005; } if (YMAX - YMIN &lt; .000001) { YMIN = YMIN - .0000005; YMAX = YMAX + .0000005; } if (ZMAX - ZMIN &lt; .000001) { ZMIN = ZMIN - .0000005; ZMAX = ZMAX + .0000005; } if (WMAX - WMIN &lt; .000001) { WMIN = WMIN - .0000005; WMAX = WMAX + .0000005; } MX = .1 * (XMAX - XMIN); MY = .1 * (YMAX - YMIN); XL = XMIN - MX; XH = XMAX + MX; YL = YMIN - MY; YH = YMAX + 1.5 * MY; SW = 640 / (XH - XL); SH = 480 / (YL - YH); _setvieworg((short)(-SW * XL), (short)(-SH * YH)); _clearscreen(_GCLEARSCREEN); YH = YH - .5 * MY; XA = (XL + XH) / 2; YA = (YL + YH) / 2; if (D &gt; 2) { ZA = (ZMAX + ZMIN) / 2; if (TRD == 1) { _setcolor(COLR[1]); _rectangle_w(_GFILLINTERIOR, SW * XL, SH * YL, SW * XH, SH * YH); fun5400(); /* Plot background grid */ } if (TRD == 4) { _setcolor(WH); _rectangle_w(_GFILLINTERIOR, SW * XL, SH * YL, SW * XH, SH * YH); } if (TRD == 5) { _moveto_w(SW * XA, SH * YL); _lineto_w(SW * XA, SH * YH); } if (TRD == 6) { for (I = 1; I &lt;= 3; I++) { XP = XL + I * (XH - XL) / 4; _moveto_w(SW * XP, SH * YL); _lineto_w(SW * XP, SH * YH); YP = YL + I * (YH - YL) / 4; _moveto_w(SW * XL, SH * YP); _lineto_w(SW * XH, SH * YP); } } } if (PJT != 1) _rectangle_w(_GBORDER, SW * XL + 1, SH * YL - 1, SW * XH - 1, SH * YH + 1); if (PJT == 1 &amp;&amp; TRD &lt; 5) _ellipse_w(_GBORDER, SW * XL - SH * (YH - YL) / 6, SH * YH, SW * XH + SH * (YH - YL) / 6, SH * YL); TT = 3.1416 / (XMAX - XMIN); PT = 3.1416 / (YMAX - YMIN); if (QM == 2) { /* In evaluate mode */ _settextposition(1, 1); printf(“: Discard : Save”); if (WID &gt;= 80) { _settextposition(1, 49); printf(“: Exit”); _settextposition(1, 69); printf(“%d K left”, (int)((filelength(fileno(F1)) - ftell(F1)) / 1024.0)); }} else { _settextposition(1, 1); if (strlen(CODE) &lt; WID - 18) _outtext(CODE); else { printf(“%.s…”, WID - 23, WID - 23, CODE); } _settextposition(1, WID - 17); printf(“F =”); _settextposition(1, WID - 7); printf(“L =”); } TIA = .05; /* Tangent of illumination angle / XZ = -TIA (XMAX - XMIN) / (ZMAX - ZMIN); YZ = TIA * (YMAX - YMIN) / (ZMAX - ZMIN); } fun3500() /* Produce sound / { FREQ = 220 pow(2, (int)(36 * (XNEW - XL) / (XH - XL)) / 12.0); DUR = 1; if (D &gt; 1) DUR = pow(2, (int)floor(.5 * (YH - YL) / (YNEW - 9 * YL / 8 + YH / 8))); /* A sound statement should be placed here / } fun3600() / Respond to user command / { if (Q &gt; 96) Q = Q - 32; / Convert to uppercase / if (QM == 2) fun5800(); / Process evaluation command / if (strchr(“ACDEHINPRSVX”, Q) == 0) fun4200(); / Display menu screen */ if (Q == ‘A’) { T = 1; QM = 0; } if (ODE &gt; 1) D = ODE + 5; if (ODE == 1) D = D + 2; if (Q == ‘C’) if (N &gt; 999) N = 999; if (Q == ‘D’) { D = 1 + D % 12; T = 1; } if (D &gt; 6) { ODE = D - 5; D = 4; } else { if (D &gt; 4) { ODE = 1; D = D - 2; } else ODE = 0; } if (Q == ‘E’) { T = 1; QM = 2; } if (Q == ‘H’) { FTH = (FTH + 1) % 3; T = 3; if (N &gt; 999) { N = 999; fun5600(); /* Set colors */ } } if (Q == ‘I’) { if (T != 1) { _setvideomode(_TEXTC80); _settextcolor(15); _setbkcolor(1L); _clearscreen(_GCLEARSCREEN); printf(“Code?”); I = 0; CODE[0] = 0; do { CODE[I] = getche(); if (CODE[I] == 8 &amp;&amp; I &gt;= 0) I = I - 2; if (CODE[I] == 27) { I = 0; CODE[I] = 13; } } while (CODE[I++] != 13 &amp;&amp; I &lt; 506); CODE[I - 1] = 0; if (CODE[0] == 0) { Q = ‘ ‘; _clearscreen(_GCLEARSCREEN);} else { T = 1; QM = 1; fun4700(); } } } if (Q == ‘N’) { NMAX = 10 * (NMAX - 1000) + 1000; if (NMAX &gt; 1E10) NMAX = 2000; } if (Q == ‘P’) { PJT = (PJT + 1) % 5; T = 3; if (N &gt; 999) N = 999; } if (Q == ‘R’) { TRD = (TRD + 1) % 7; T = 3; if (N &gt; 999) { N = 999; fun5600(); /* Get dimension and order */ } } if (Q == ‘S’) { SND = (SND + 1) % 2; T = 3; } if (Q == ‘V’) { SAV = (SAV + 1) % 5; FAV[0] = 87 + SAV % 4; T = 3; if (N &gt; 999) N = 999; } if (Q == ‘X’) T = 0; } fun3900() /* Calculate fractal dimension / { if (N &gt;= 1000) { / Wait for transient to settle */ if ((int)N == 1000) { D2MAX = pow(XMAX - XMIN, 2); D2MAX = D2MAX + pow(YMAX - YMIN, 2); D2MAX = D2MAX + pow(ZMAX - ZMIN, 2); D2MAX = D2MAX + pow(WMAX - WMIN, 2); } J = (P + 1 + (int)floor(480 * (float)rand() / 32768.0)) % 500; DX = XNEW - XS[J]; DY = YNEW - YS[J]; DZ = ZNEW - ZS[J]; DW = WNEW - WS[J]; D2 = DX * DX + DY * DY + DZ * DZ + DW * DW; if (D2 &lt; .001 * TWOD * D2MAX) N2 = N2 + 1; if (D2 &lt;= .00001 * TWOD * D2MAX) { N1 = N1 + 1; F = .434294 * log(N2 / (N1 - .5)); _settextposition(1, WID - 14); printf(“%5.2f”, F); } } } fun4100() /* Project onto a sphere / { TH = TT (XMAX - XP); PH = PT * (YMAX - YP); XP = XA + .36 * (XH - XL) * cos(TH) * sin(PH); YP = YA + .5 * (YH - YL) * cos(PH); } fun4200() /* Display menu screen */ { _setvideomode(_TEXTC80); _settextcolor(15); _setbkcolor(1L); regs.h.ah = 1; regs.h.ch = 1; regs.h.cl = 0; int86(16, &amp;regs, &amp;regs); /* Turn cursor off */ _clearscreen(_GCLEARSCREEN); while (Q == 0 || strchr(“AEIX”, Q) == 0) { _settextposition(1, 27); printf(“STRANGE ATTRACTOR PROGRAM”); printf(“%26cIBM PC QuickC Version 2.0”, ‘ ‘); printf(“%26c(c) 1993 by J. C. Sprott”, ‘ ‘); printf(“”); printf(“”); printf(“%26cA: Search for attractors”, ‘ ‘); printf(“%26cC: Clear screen and restart”, ‘ ‘); if (ODE &gt; 1) { printf(“%26cD: System is 4-D special map %c ”, ‘ ‘, 87 + ODE);} else { printf(“%26cD: System is %d-D polynomial”, ‘ ‘, D); if (ODE == 1) printf(“ODE”); else printf(“map”); } printf(“%26cE: Evaluate attractors”, ‘ ‘); printf(“%26cH: Fourth dimension is”, ‘ ‘); if (FTH == 0) printf(“projection”); if (FTH == 1) printf(“bands ”); if (FTH == 2) printf(“colors ”); printf(“%26cI: Input code from keyboard”, ‘ ‘); printf(“%26cN: Number of iterations is 10^%1.0f”, ‘ ‘, log10(NMAX - 1000)); printf(“%26cP: Projection is”, ‘ ‘); if (PJT == 0) printf(“planar ”); if (PJT == 1) printf(“spherical”); if (PJT == 2) printf(“horiz cyl”); if (PJT == 3) printf(“vert cyl ”); if (PJT == 4) printf(“toroidal ”); printf(“%26cR: Third dimension is”, ‘ ‘); if (TRD == 0) printf(“projection”); if (TRD == 1) printf(“shadow ”); if (TRD == 2) printf(“bands ”); if (TRD == 3) printf(“colors ”); if (TRD == 4) printf(“anaglyph ”); if (TRD == 5) printf(“stereogram”); if (TRD == 6) printf(“slices ”); printf(“%26cS: Sound is”, ‘ ‘); if (SND == 0) printf(“off”); if (SND == 1) printf(“on ”); printf(“%26cV:”, ‘ ‘); if (SAV == 0) printf(“No data will be saved ”); if (SAV &gt; 0) printf(“%c will be saved in %cDATA.DAT”, FAV[0], FAV[0]); printf(“%26cX: Exit program”, ‘ ‘); if (kbhit()) Q = getch(); else Q = 0; if (Q) fun3600(); /* Respond to user command / } } fun4700() / Get dimension and order / { D = 1 + (int)floor((CODE[0] - 65) / 4); if (D &gt; 6) { ODE = CODE[0] - 87; D = 4; fun6200(); / Special function */ } else { if (D &gt; 4) { D = D - 2; ODE = 1; } else ODE = 0; O = 2 + (CODE[0] - 65) % 4; M = 1; for (I = 1; I &lt;= D; I++) {M = M * (O + I);} if (D &gt; 2) for (I = 3; I &lt;= D; I++) {M = M / (I - 1);} } if (strlen(CODE) != M + 1 &amp;&amp; QM == 1) { printf(“”); /* Illegal code warning / while (strlen(CODE) &lt; M + 1) strcat(CODE, “M”); if (strlen(CODE) &gt; M + 1) CODE[M + 1] = 0; } } fun4900() / Save attractor to disk file SA.DIC */ { F1 = fopen(“SA.DIC”, “a”); fprintf(F1, “%s%5.2f%5.2f”, CODE, F, L); fclose(F1); } fun5000() /* Plot point on screen / { C4 = WH; if (D &gt; 3) { if (FTH == 1) if ((int)floor(30 (W - WMIN) / (WMAX - WMIN)) % 2) return(0); if (FTH == 2) C4 = 1 + (int)floor(NC * (W - WMIN) / (WMAX - WMIN) + NC) % NC; } if (D &lt; 3) { /* Skip 3-D stuff */ _setpixel_w(SW * XP, SH * YP); return(0); } if (TRD == 0) { _setcolor(C4); _setpixel_w(SW * XP, SH * YP); } if (TRD == 1) { if (D &gt; 3 &amp;&amp; FTH == 2) { _setcolor(C4); _setpixel_w(SW * XP, SH * YP); } else { C = _getpixel_w(SW * XP, SH * YP); if (C == COLR[2]) { _setcolor(COLR[3]); _setpixel_w(SW * XP, SH * YP);} else { if (C != COLR[3]) { _setcolor(COLR[2]); _setpixel_w(SW * XP, SH * YP); } } } XP = XP - XZ * (Z - ZMIN); YP = YP - YZ * (Z - ZMIN); if (_getpixel_w(SW * XP, SH * YP) == COLR[1]) { _setcolor(0); _setpixel_w(SW * XP, SH * YP); } } if (TRD == 2) { if (D &gt; 3 &amp;&amp; FTH == 2 &amp;&amp; ((int)floor(15 * (Z - ZMIN) / (ZMAX - ZMIN) + 2) % 2) == 1) { _setcolor(C4);} else { C = COLR[(int)floor(60 * (Z - ZMIN) / (ZMAX - ZMIN) + 4) % 4]; _setcolor(C); } _setpixel_w(SW * XP, SH * YP); } if (TRD == 3) { _setcolor(COLR[(int)floor(NC * (Z - ZMIN) / (ZMAX - ZMIN) + NC) % NC]); _setpixel_w(SW * XP, SH * YP); } if (TRD == 4) { XRT = XP + XZ * (Z - ZA); C = _getpixel_w(SW * XRT, SH * YP); if (C == WH) { _setcolor(RD); _setpixel_w(SW * XRT, SH * YP); } if (C == CY) { _setcolor(BK); _setpixel_w(SW * XRT, SH * YP); } XLT = XP - XZ * (Z - ZA); C = _getpixel_w(SW * XLT, SH * YP); if (C == WH) { _setcolor(CY); _setpixel_w(SW * XLT, SH * YP); } if (C == RD) { _setcolor(BK); _setpixel_w(SW * XLT, SH * YP); } } if (TRD == 5) { HSF = 2; /* Horizontal scale factor / XRT = XA + (XP + XZ (Z - ZA) - XL) / HSF; _setcolor(C4); _setpixel_w(SW * XRT, SH * YP); XLT = XA + (XP - XZ * (Z - ZA) - XH) / HSF; _setcolor(C4); _setpixel_w(SW * XLT, SH * YP); } if (TRD == 6) { DZ = (15 * (Z - ZMIN) / (ZMAX - ZMIN) + .5) / 16; XP = (XP - XL + ((int)floor(16 * DZ) % 4) * (XH - XL)) / 4 + XL; YP = (YP - YL + (3 - (int)floor(4 * DZ) % 4) * (YH - YL)) / 4 + YL; _setcolor(C4); _setpixel_w(SW * XP, SH * YP); } } fun5400() /* Plot background grid */ { _setcolor(0); for (I = 0; I &lt;= 15; I++) { /* Draw 15 vertical grid lines / XP = XMIN + I (XMAX - XMIN) / 15; _moveto_w(SW * XP, SH * YMIN); _lineto_w(SW * XP, SH * YMAX); } for (I = 0; I &lt;= 10; I++) { /* Draw 10 horizontal grid lines / YP = YMIN + I (YMAX - YMIN) / 10; _moveto_w(SW * XMIN, SH * YP); _lineto_w(SW * XMAX, SH * YP); } } fun5600() /* Set colors / { NC = 15; / Number of colors / COLR[0] = 0; COLR[1] = 8; COLR[2] = 7; COLR[3] = 15; if (TRD == 3 || (D &gt; 3 &amp;&amp; FTH == 2 &amp;&amp; TRD != 1)) { for (I = 0; I &lt;= NC; I++) COLR[I] = I + 1; } WH = 15; BK = 8; RD = 12; CY = 11; } fun5800() / Process evaluation command */ { if (Q == ‘ ‘) { T = 2; NE = NE + 1; _clearscreen(_GCLEARSCREEN); } if (Q == 13) { T = 2; NE = NE + 1; _clearscreen(_GCLEARSCREEN); fun5900(); /* Save favorite attractors to disk */ } if (Q == 27) { _clearscreen(_GCLEARSCREEN); fun6000(); /* Update SA.DIC file / Q = ‘ ‘; QM = 0; } else { if (strchr(“CHNPRVS”, Q) == 0) Q = 0; } } fun5900() / Save favorite attractors to disk file FAVORITE.DIC / { F2 = fopen(“FAVORITE.DIC”, “a”); fprintf(F2, CODE); fclose(F2); } fun6000() / Update SA.DIC file */ { _settextposition(11, 9); printf(“Evaluation complete”); _settextposition(12, 8); printf(&quot; %d cases evaluated&quot;, (int)NE); F2 = fopen(“SATEMP.DIC”, “w”); if (QM == 2) fprintf(F2, CODE); while (feof(F1) == 0) { fgets(CODE, 515, F1); if (feof(F1) == 0) fprintf(F2, CODE); } fcloseall(); remove(“SA.DIC”); rename(“SATEMP.DIC”, “SA.DIC”); } fun6200() /* Special function definitions / { ZNEW = X X + Y * Y; /* Default 3rd and 4th dimension / WNEW = (N - 100) / 900; if (N &gt; 1000) WNEW = (N - 1000) / (NMAX - 1000); if (ODE == 2) { M = 10; XNEW = A[1] + A[2] X + A[3] * Y + A[4] * fabs(X) + A[5] * fabs(Y); YNEW = A[6] + A[7] * X + A[8] * Y + A[9] * fabs(X) + A[10] * fabs(Y); } if (ODE == 3) { M = 14; XNEW = A[1] + A[2] * X + A[3] * Y + ((int)(A[4] * X + .5) &amp; (int)(A[5] * Y + .5)) + ((int)(A[6] * X + .5) | (int)(A[7] * Y + .5)); YNEW = A[8] + A[9] * X + A[10] * Y + ((int)(A[11] * X + .5) &amp; (int)(A[12] Y + .5)) + ((int)(A[13] X + .5) | (int)(A[14] * Y + .5)); } if (ODE == 4) { M = 14; XNEW = A[1] + A[2] * X + A[3] * Y + A[4] * pow(fabs(X), A[5]) + A[6] * pow(fabs(Y), A[7]); YNEW = A[8] + A[9] * X + A[10] * Y + A[11] * pow(fabs(X), A[12]) + A[13] pow(fabs(Y), A[14]); } if (ODE == 5) { M = 18; XNEW = A[1] + A[2] X + A[3] * Y + A[4] * sin(A[5] * X + A[6]) + A[7] * sin(A[8] * Y + A[9]); YNEW = A[10] + A[11] * X + A[12] * Y + A[13] * sin(A[14] * X + A[15]) + A[16] * sin(A[17] * Y + A[18]); } if (ODE == 6) { M = 6; if (N &lt; 2) { AL = TWOPI / (13 + 10 * A[6]); SINAL = sin(AL); COSAL = cos(AL); } DUM = X + A[2] * sin(A[3] * Y + A[4]); XNEW = 10 * A[1] + DUM * COSAL + Y * SINAL; YNEW = 10 * A[5] - DUM * SINAL + Y * COSAL; } if (ODE == 7) { M = 9; XNEW = X + EPS * A[1] * Y; YNEW = Y + EPS * (A[2] * X + A[3] * X * X * X + A[4] * X * X * Y + A[5] * X * Y * Y + A[6] * Y + A[7] * Y * Y * Y + A[8] * sin(Z)); ZNEW = Z + EPS * (A[9] + 1.3); if (ZNEW &gt; TWOPI) ZNEW = ZNEW - TWOPI; } } fun6700() /* Project onto a horizontal cylinder / { PH = PT (YMAX - YP); YP = YA + .5 * (YH - YL) * cos(PH); } fun6800() /* Project onto a vertical cylinder / { TH = TT (XMAX - XP); XP = XA + .5 * (XH - XL) * cos(TH); } fun6900() /* Project onto a torus (unity aspect ratio) / { TH = TT (XMAX - XP); PH = 2 * PT * (YMAX - YP); XP = XA + .18 * (XH - XL) * (1 + cos(TH)) * sin(PH); YP = YA + .25 * (YH - YL) * (1 + cos(TH)) * cos(PH); } fun7000() /* Save data */ { if ((int)N == 1000) { fclose(F3); F3 = fopen(FAV, “w”); } if (SAV == 1) DUM = XNEW; if (SAV == 2) DUM = YNEW; if (SAV == 3) DUM = ZNEW; if (SAV == 4) DUM = WNEW; fprintf(F3, “%f”, DUM); } ``` "],
["appendix-e.html", "14 Appendix E", " 14 Appendix E "],
["appendix-f.html", "15 Appendix F", " 15 Appendix F "]
]
